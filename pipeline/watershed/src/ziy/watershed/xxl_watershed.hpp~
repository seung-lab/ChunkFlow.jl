//
// Copyright (C) 2010  Aleksandar Zlateski <zlateski@mit.edu>
// ----------------------------------------------------------
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//

#ifndef ZI_WATERSHED_XXL_WATERSHED_HPP
#define ZI_WATERSHED_XXL_WATERSHED_HPP 1

#include <zi/watershed/quickie.hpp>
#include <zi/watershed/detail/xxl_chunk.hpp>
#include <zi/watershed/detail/xxl_queue.hpp>
#include <zi/bits/cstdint.hpp>
#include <zi/bits/bind.hpp>
#include <zi/bits/shared_ptr.hpp>
#include <zi/bits/unordered_set.hpp>
#include <zi/memory/detail/mmap_file.hpp>
#include <zi/concurrency/mutex.hpp>
#include <zi/concurrency/rwmutex.hpp>
#include <zi/concurrency/task_manager.hpp>

#include <zi/utility/non_copyable.hpp>
#include <zi/utility/string_printf.hpp>

#include <cstddef>
#include <iostream>
#include <vector>

namespace zi {
namespace watershed {

namespace detail {

struct watershed_task
{
    int32_t affinity_bitsize;
    int32_t id_bitsize      ;
    int32_t x;
    int32_t y;
    int32_t z;
};

} // namespace detail

template< class AffinityType, class IdType, class SizeType >
class xxl_watershed_impl: non_copyable
{
public:
    typedef IdType id_type;
    typedef xxl_watershed_impl< AffinityType, IdType, SizeType >                  type;

    typedef std::vector< std::pair< AffinityType, std::pair< IdType, IdType > > > dendr_type;

    typedef unordered_map< std::pair< IdType, IdType >, AffinityType > edgemap_type;

    typedef chunk< IdType >                                                       chunk_type;
    typedef shared_ptr< chunk< IdType > >                                         chunk_ptr;
    typedef std::pair< IdType, IdType >                                           id_pair;

    typedef detail::xxl_chunk< AffinityType, IdType, SizeType >        xxl_chunk    ;
    typedef shared_ptr< xxl_chunk >                                    xxl_chunk_ptr;

private:
    const std::string        file_prefix_;
    const std::size_t        size_;
    mutex                    mutex_;
    const AffinityType       hi_;
    const AffinityType       low_;
    const AffinityType       mst_;
    const SizeType           size_thold_;

    class chunk_manager: non_copyable
    {
    private:

        const std::size_t             size_;
        std::size_t                   dims_[ 3 ];
        std::vector< xxl_chunk_ptr >  chunks_;

    public:
        chunk_manager( std::size_t xdim, std::size_t ydim, std::size_t zdim )
            : size_( xdim * ydim * zdim ),
              dims_(),
              chunks_( size_ )
        {
            dims_[ 0 ] = xdim;
            dims_[ 1 ] = ydim;
            dims_[ 2 ] = zdim;
        }

        const std::size_t xdim() const
        {
            return dims_[ 0 ];
        }

        const std::size_t ydim() const
        {
            return dims_[ 1 ];
        }

        const std::size_t zdim() const
        {
            return dims_[ 2 ];
        }

        const std::size_t dim( std::size_t i ) const
        {
            return dims_[ i ];
        }

        xxl_chunk_ptr& get( std::size_t x, std::size_t y, std::size_t z )
        {
            return chunks_[ x * dims_[ 2 ] * dims_[ 1 ] + y * dims_[ 2 ] + z ];
        }

        const xxl_chunk_ptr& get( std::size_t x, std::size_t y, std::size_t z ) const
        {
            return chunks_[ x * dims_[ 2 ] * dims_[ 1 ] + y * dims_[ 2 ] + z ];
        }

        void set( std::size_t x, std::size_t y, std::size_t z, xxl_chunk_ptr c )
        {
            chunks_[ x * dims_[ 2 ] * dims_[ 1 ] + y * dims_[ 2 ] + z ] = c;
        }

        xxl_chunk_ptr& operator()( std::size_t x, std::size_t y, std::size_t z )
        {
            return chunks_[ x * dims_[ 2 ] * dims_[ 1 ] + y * dims_[ 2 ] + z ];
        }

        const xxl_chunk_ptr& operator()( std::size_t x, std::size_t y, std::size_t z ) const
        {
            return chunks_[ x * dims_[ 2 ] * dims_[ 1 ] + y * dims_[ 2 ] + z ];
        }

        xxl_chunk_ptr& operator[]( std::size_t s )
        {
            return chunks_[ s ];
        }

        const xxl_chunk_ptr& operator[]( std::size_t s ) const
        {
            return chunks_[ s ];
        }


    };

    chunk_manager chunks_;
    task_manager::simple serial_tm_;

    std::vector< SizeType > sizes_;
    std::vector< IdType   > order_;
    disjoint_sets< IdType > trees_;

    std::size_t num_ready_  ;
    IdType num_domains_;

    detail::xxl_queue< std::pair< AffinityType, id_pair > > queue_;

public:
    explicit xxl_watershed_impl( const std::string& file_prefix,
                                 const std::size_t  xdim,
                                 const std::size_t  ydim,
                                 const std::size_t  zdim,
                                 const AffinityType& hi,
                                 const AffinityType& low,
                                 const AffinityType& mst,
                                 const SizeType& size_thold )
        : file_prefix_( file_prefix ),
          size_( xdim * ydim * zdim ),
          mutex_(),
          hi_( hi ),
          low_( low ),
          mst_( mst ),
          size_thold_( size_thold ),
          chunks_( xdim, ydim, zdim ),
          serial_tm_( 1 ),
          sizes_(),
          order_(),
          trees_( 1 ),
          num_ready_(),
          num_domains_( 0 ),
          queue_()
    {

        int32_t chunk_sizes[ size_ * 3 ];
        mem::mmap_file::read( file_prefix_ + ".chunksizes", chunk_sizes, size_ * 12 );

        for ( std::size_t x = 0, idx = 0; x < xdim; ++x )
        {
            for ( std::size_t y = 0; y < ydim; ++y )
            {
                for ( std::size_t z = 0; z < zdim; ++z, ++idx )
                {
                    std::cout << "chunk [ " << x << ' '
                              << y << ' ' << z << " ] size: [ "
                              << chunk_sizes[ idx*3   ] << ' ';
                    std::cout << chunk_sizes[ idx*3+1 ] << ' ';
                    std::cout << chunk_sizes[ idx*3+2 ] << " ]\n";

                    int flags = 0;
                    flags |= x == 0 ? XFRONT : 0;
                    flags |= y == 0 ? YFRONT : 0;
                    flags |= z == 0 ? ZFRONT : 0;
                    flags |= x == xdim - 1 ? XBACK : 0;
                    flags |= y == ydim - 1 ? YBACK : 0;
                    flags |= z == zdim - 1 ? ZBACK : 0;
                    //flags = 0;

                    chunks_( x, y, z ) = xxl_chunk_ptr( new xxl_chunk( x, y, z, flags,
                                                                       chunk_sizes[ idx*3   ],
                                                                       chunk_sizes[ idx*3+1 ],
                                                                       chunk_sizes[ idx*3+2 ],
                                                                       file_prefix ) );
                }
            }
        }
    }

    void process_chunk( xxl_chunk_ptr c )
    {
        c->conn()->load();
        c->save_border_affinities();

        std::vector< SizeType > sizes;
        dendr_type              dendr;

        chunk_type &this_chunk = *( c->get().get()  );
        affinity_matrix< AffinityType > &this_conn  = *( c->conn().get() );

        quickie( this_conn,
                 hi_, low_, mst_, size_thold_,
                 this_chunk, c->flags(), dendr, sizes, false );

        c->flush_chunk( true );
        c->save_sizes( sizes );
        c->save_dendr( dendr );

        this_chunk.deallocate();

        {
            mutex::guard g( mutex_ );
            std::cout << "Done chunk [ " << c->x() << ' '
                      << c->y() << ' ' << c->z() << " ] :: "
                      << "domains = " << c->count() << " , "
                      << dendr.size() << "\n"
                      << std::flush;
        }

    }

    void merge_sides( std::vector< IdType >& a0,
                      std::vector< IdType >& a1,
                      std::vector< IdType >& b0,
                      std::vector< IdType >& b1,
                      IdType aoffset,
                      IdType boffset,
                      std::vector< AffinityType >& conn,
                      unordered_set< id_pair >& all,
                      edgemap_type& edges )
    {
        AffinityType dend_min_ = std::min( low_, mst_ );

        for ( std::size_t i = 0; i < a0.size(); ++i )
        {
            if ( a0[ i ] && b1[ i ] )
            {
                if ( a1[ i ] || b0[ i ] )
                {
                    if ( a1[ i ] )
                    {
                        all.insert( std::make_pair( aoffset + a1[ i ],
                                                    boffset + b1[ i ] ));
                    }
                    else
                    {
                        all.insert( std::make_pair( aoffset + a0[ i ],
                                                    boffset + b0[ i ] ));
                    }
                }
                else
                {
                    if ( conn[ i ] >= dend_min_ )
                    {
                        id_pair x = std::make_pair( a0[ i ] + aoffset,
                                                    b1[ i ] + boffset );

                        typename edgemap_type::iterator it = edges.find( x );

                        if ( it == edges.end() )
                        {
                            edges.insert( std::make_pair( x, conn[ i ] ) );
                        }
                        else
                        {
                            if ( it->second < conn[ i ] )
                            {
                                it->second = conn[ i ];
                            }
                        }
                    }
                }
            }

            if ( a1[ i ] && ( !a0[ i ] ) )
            {
                std::cout << "error at: " << aoffset << "\n";
            }

            if ( b0[ i ] && ( !b1[ i ] ) )
            {
                std::cout << "error at: " << boffset << "\n";
            }
        }

    }

    void fetch_chunk_sizes( xxl_chunk_ptr c )
    {
        std::vector< SizeType > v;
        c->get_sizes( v );

        std::size_t offset = c->offset();

        {
            mutex::guard g( mutex_ );
            sizes_[ 0 ] += v[ 0 ];
        }

        std::size_t tot_this = v[ 0 ];

        for ( std::size_t i = 1; i < v.size(); ++i )
        {
            sizes_[ i + offset ] = v[ i ];
            tot_this += v[ i ];
        }

        {
            mutex::guard g( mutex_ );
            ++num_ready_;

            if ( num_ready_ == size_ )
            {
                trees_.resize( num_domains_ );
                serial_tm_.start();
            }

            std::cout << "sizes of " << num_ready_ << " / "
                      << size_ << " saved\n";
        }

    }

    void merge_pairs( xxl_chunk_ptr c )
    {
        std::vector< id_pair > v;
        c->get_merge_pairs( v );

        std::size_t cnt = 0;

        FOR_EACH( it, v )
        {
            const IdType v1 = trees_.find_set( it->first  );
            const IdType v2 = trees_.find_set( it->second );

            if ( v1 == 0 || v2 == 0 )
            {
                std::cout << "ERROR\n";
            }

            if ( v1 != v2 )
            {
                sizes_[ v1 ] += sizes_[ v2 ];
                sizes_[ v2 ]  = 0;
                std::swap( sizes_[ trees_.join( v1, v2 ) ], sizes_[ v1 ] );
                ++cnt;
            }
        }

        std::cout << "Merged for prefix: " << c->prefix()
                  << ": " << cnt << " out of " << v.size() << "\n";
    }

    void process_chunk_borders( xxl_chunk_ptr c )
    {
        std::size_t x = c->xpos();
        std::size_t y = c->ypos();
        std::size_t z = c->zpos();

        if ( x + y + z == 0 )
        {
            return;
        }

        edgemap_type             edges;
        unordered_set< id_pair > all_same;

        std::vector< AffinityType > conn;
        std::vector< IdType > a0, a1, b0, b1;

        if ( x > 0 )
        {
            xxl_chunk_ptr c2 = chunks_( x-1, y, z );
            c->get_border_affinities( 0, conn );
            c->get_seg_faces( 0, 1, b0, b1 );
            c2->get_seg_faces( 0, 0, a0, a1 );
            merge_sides( a0, a1, b0, b1, c2->offset(), c->offset(), conn, all_same, edges );
        }

        if ( y > 0 )
        {
            xxl_chunk_ptr c2 = chunks_( x, y-1, z );
            c->get_border_affinities( 1, conn );
            c->get_seg_faces( 1, 1, b0, b1 );
            c2->get_seg_faces( 1, 0, a0, a1 );
            merge_sides( a0, a1, b0, b1, c2->offset(), c->offset(), conn, all_same, edges );
        }

        if ( z > 0 )
        {
            xxl_chunk_ptr c2 = chunks_( x, y, z-1 );
            c->get_border_affinities( 2, conn );
            c->get_seg_faces( 2, 1, b0, b1 );
            c2->get_seg_faces( 2, 0, a0, a1 );
            merge_sides( a0, a1, b0, b1, c2->offset(), c->offset(), conn, all_same, edges );
        }

        dendr_type more_dend( edges.size() );

        std::size_t idx = 0;
        FOR_EACH( it, edges )
        {
            more_dend[ idx++ ] = std::make_pair( it->second, it->first );
        }

        zi::sort( more_dend.begin(), more_dend.end(),
                  std::greater< std::pair< AffinityType, id_pair > >() );

        c->save_merge_graph( more_dend );
        c->save_merge_pairs( all_same  );

        {
            mutex::guard g( mutex_ );
            std::cout << "process_chunk_borders [ " << x << " "
                      << y << " " << z << " ] : "
                      << c->merge_pairs_size() << " : "
                      << c->merge_graph_size() << "\n";
        }

        serial_tm_.push_back( zi::run_fn( zi::bind( &type::merge_pairs, this, c ) ));


    }

    void update_chunk_data( xxl_chunk_ptr c )
    {
        id_type  off = c->offset();

        dendr_type dendr, new_dendr;
        c->get_dendr( dendr );

        FOR_EACH( it, dendr )
        {
            id_type a1 = order_[ it->second.first  + off ];
            id_type a2 = order_[ it->second.second + off ];

            if ( a1 != a2  && a1 && a2 )
            {
                new_dendr.push_back( std::make_pair( it->first, std::make_pair( a1, a2 ) ));
            }
        }

        c->get_merge_graph( dendr );

        FOR_EACH( it, dendr )
        {
            id_type a1 = order_[ it->second.first  ];
            id_type a2 = order_[ it->second.second ];

            if ( a1 != a2 && a1 && a2 )
            {
                new_dendr.push_back( std::make_pair( it->first, std::make_pair( a1, a2 ) ));
            }
        }

        c->save_dendr( new_dendr );

        dendr.clear();
        new_dendr.clear();

        chunk_ptr cp = c->load_chunk();
        id_type *seg = cp->data();

        for ( std::size_t i = 0; i < cp->size(); ++i )
        {
            if ( seg[ i ] )
            {
                seg[ i ] = order_[ seg[ i ] + off ];
            }
        }

        c->flush_chunk( false );
    }

    void run( std::size_t num_threads = 5 )
    {
        task_manager::simple tm( num_threads );
        tm.start();

        for ( std::size_t i = 0; i < size_; ++i )
        {
            tm.push_back( zi::run_fn( zi::bind( &type::process_chunk,
                                                this,
                                                chunks_[ i ] ) ) );
        }

        tm.join();

        num_domains_ = 0;
        for ( std::size_t i = 0; i < size_; ++i )
        {
            chunks_[ i ]->offset( num_domains_ );
            num_domains_ += chunks_[ i ]->count() - 1;
        }

        ++num_domains_;

        std::cout << "Total domains: " << num_domains_ << "\n";
        sizes_.resize( num_domains_ );

        tm.start();
        for ( std::size_t i = 0; i < size_; ++i )
        {
            tm.push_back( zi::run_fn( zi::bind( &type::fetch_chunk_sizes,
                                                this,
                                                chunks_[ i ] ) ) );
        }

        for ( std::size_t i = 0; i < size_; ++i )
        {
            tm.push_back( zi::run_fn( zi::bind( &type::process_chunk_borders,
                                                this,
                                                chunks_[ i ] ) ) );
        }

        tm.join();
        serial_tm_.join();

        std::size_t expecxt_no = 0;

        for ( std::size_t i = 0; i < size_; ++i )
        {
            xxl_chunk_ptr c = chunks_[ i ];

            if ( c->dendr_size() )
            {
                queue_.add_source( c->prefix() + ".dendr",
                                   c->dendr_size(),
                                   c->offset() );
                expecxt_no += c->dendr_size();
            }

            if ( c->merge_graph_size() )
            {
                queue_.add_source( c->prefix() + ".merge_graph",
                                   c->merge_graph_size(), 0 );
                expecxt_no += c->merge_graph_size();
            }
        }


        std::size_t actual_no = 0;
        //
        // apply size threshold
        //

        while ( !queue_.empty() )
        {
            ++actual_no;

            if ( queue_.top().first < mst_ )
            {
                break;
            }

            const id_type off = queue_.top_key();
            const id_type v1  = trees_.find_set( queue_.top().second.first  + off );
            const id_type v2  = trees_.find_set( queue_.top().second.second + off );

            if ( v1 == 0 || v2 == 0 )
            {
                std::cout << "ERRRRRRRRRROR\n";
            }

            if ( v1 != v2 )
            {
                if ( sizes_[ v1 ] < size_thold_ || sizes_[ v2 ] < size_thold_ )
                {
                    sizes_[ v1 ] += sizes_[ v2 ];
                    sizes_[ v2 ]  = 0;
                    std::swap( sizes_[ trees_.join( v1, v2 ) ], sizes_[ v1 ] );
                }
            }

            queue_.pop();
        }

        order_.resize( num_domains_ );

        id_type new_index = 1;
        for ( id_type i = 1; i < num_domains_; ++i )
        {
            if ( sizes_[ i ] )
            {
                if ( sizes_[ i ] >= size_thold_ )
                {
                    sizes_[ new_index ] = sizes_[ i ];
                    order_[ i ] = new_index;
                    ++new_index;
                }
                else
                {
                    sizes_[ 0 ] += sizes_[ i ];
                    sizes_[ i ]  = order_[ i ] = 0;
                }
            }
        }

        for ( id_type i = 1; i < num_domains_; ++i )
        {
            if ( !order_[ i ] )
            {
                order_[ i ] = order_[ trees_.find_set( i ) ];
            }
        }

        trees_.resize( new_index );
        sizes_.resize( new_index );

        std::size_t tot = 0;
        FOR_EACH( it, sizes_ )
        {
            tot += *it;
        }

        mem::mmap_file::write_n( file_prefix_ + ".all_sizes",
                                 sizes_.begin(),
                                 new_index );
        sizes_.clear();


        std::cout << "Total size: " << new_index << " / " << tot << "\n";

        tm.start();

        for ( std::size_t i = 0; i < size_; ++i )
        {
            tm.push_back( zi::run_fn( zi::bind( &type::update_chunk_data,
                                                this,
                                                chunks_[ i ] ) ) );
        }

        tm.join();

        std::fill( sizes_.begin(), sizes_.end(), 0 );

        queue_.clear();

        for ( std::size_t i = 0; i < size_; ++i )
        {
            xxl_chunk_ptr c = chunks_[ i ];
            if ( c->dendr_size() )
            {
                queue_.add_source( c->prefix() + ".dendr",
                                   c->dendr_size(), 0 );
            }
        }

        id_type round = 0;

        while ( !queue_.empty() )
        {
            if ( queue_.top().first < low_ )
            {
                break;
            }

            const id_type v1  = trees_.find_set( queue_.top().second.first  );
            const id_type v2  = trees_.find_set( queue_.top().second.second );

            if ( v1 == 0 || v2 == 0 )
            {
                std::cout << "ERRRRRRRRRROR\n";
            }

            if ( v1 != v2 )
            {
                sizes_[ v1 ] = sizes_[ v2 ] = ++round;
                trees_.join( v1, v2 );
            }

            queue_.pop();
        }

        std::cout << "FINAL DEND SIZE: " << round << "\n";


    }

};

void test( const std::string& filename )
{
    detail::watershed_task ws;
    std::string f = filename + ".metadata";
    mem::mmap_file::get( f, ws );
    std::cout << ws.affinity_bitsize << "\n";
    std::cout << ws.id_bitsize << "\n";
    std::cout << ws.x << "\n";
    std::cout << ws.y << "\n";
    std::cout << ws.z << "\n";

    std::size_t total = ws.x * ws.y * ws.z;

    int32_t chunk_sizes[ total * 3 ];

    f = filename + ".chunksizes";
    mem::mmap_file::read( f, chunk_sizes, total * 12 );

    xxl_watershed_impl< float, int32_t, int32_t > xxlws( filename, ws.x, ws.y, ws.z, 0.999, 0.2, 0.1, 20 );
    xxlws.run( 2 );
}

} // namespace watershed
} // namespace zi

#endif
